# CH552で外部ボタンとサーボモーターを制御する

## 外部ボタン（タクトスイッチ）の入力

外部ボタンを使用して入力を受け取る方法を説明します。  
以下の手順で接続を行い、サンプルコードを試してください。

### 配線
- ボタンの片方の端子をCH552のP3.3ピンに接続します。
- ボタンのもう片方の端子をGNDに接続します。
- P3.3ピンにプルアップ抵抗（10kΩ程度）を接続します。

### サンプルコード
以下のコードは、ボタンが押されたときにLEDをONにする．

```cpp
#define BUTTON_PIN 33 // P3.3に接続されたボタン
#define LED 15


void setup() {
  pinMode(BUTTON_PIN, INPUT_PULLUP); // ボタンピンをプルアップ入力モードに設定
  pinMode(LED, OUTPUT); // LEDを出力モードに
}

void loop() {
  if (digitalRead(BUTTON_PIN) == LOW) { // ボタンが押された場合
    digitalWrite(LED, HIGH); // LED 点灯
    delay(200); // チャタリング防止のための遅延
  }else{//そうでないとき
    digitalWrite(LED, LOW); // LED 消灯
  }
}
```


## サーボモーターの制御

サーボモーターを制御する方法を説明します。  
CH552ではPWM信号を使用してサーボモーターを動かします。

### 配線
- サーボモーターの制御線をCH552のP1.0ピンに接続します。
- サーボモーターの電源線（赤）を5V(VCC)に接続します。
- サーボモーターのGND線（黒）をGNDに接続します。

### サンプルコード
以下のコードは、サーボモーターを0度から180度まで動かす例です。

```cpp
// CH552 / CH55xDuino 用・ソフトウェアサーボ
// 信号: P1.0 (D10) に接続

#define SERVO_PIN 10       // P1.0
#define FRAME_US 20000     // 1フレーム 20ms = 50Hz

void setup() {
  pinMode(SERVO_PIN, OUTPUT);
  digitalWrite(SERVO_PIN, LOW);
}

// 角度(0–180度) -> パルス幅(1000–2000µs)に変換して1フレーム分出力
void writeServoAngle(int angle) {
  if (angle < 0) angle = 0;
  if (angle > 180) angle = 180;

  // 標準的なサーボ: 0°=1000µs, 180°=2000µs
  // 必要なら 500–2500µs に広げてください。
  int pulse = 1000 + (angle * 1000) / 180;  // 1000〜2000µs

  // 20ms周期のうち、先頭をHIGH(パルス幅)にして残りをLOW
  digitalWrite(SERVO_PIN, HIGH);
  delayMicroseconds(pulse);
  digitalWrite(SERVO_PIN, LOW);

  // 残りのフレーム時間を待つ
  delayMicroseconds(FRAME_US - pulse);
}

void loop() {
  // 0→180°へ
  for (int angle = 0; angle <= 180; angle += 10) {
    // サーボは継続パルスが必要なので、角度ごとに約0.5秒(=25フレーム)保持
    for (int i = 0; i < 25; i++) writeServoAngle(angle);
  }
  // 180→0°へ
  for (int angle = 180; angle >= 0; angle -= 10) {
    for (int i = 0; i < 25; i++) writeServoAngle(angle);
  }
}
```

## 講習テストコード


- **ボタン0**：全LEDを点灯
- **ボタン1**：全LEDを消灯
- **ボタン2**：LED0・LED2を点灯、LED1を消灯

#### 使用ピン

| 名前           | GPIO番号 | 用途       |
|----------------|----------|------------|
| `LED_BUILTIN0` | GPIO15   | LED出力1   |
| `LED_BUILTIN1` | GPIO34   | LED出力2   |
| `LED_BUILTIN2` | GPIO33   | LED出力3   |
| `BUTTON_PIN0`  | GPIO12   | ボタン入力1（全点灯） |
| `BUTTON_PIN1`  | GPIO13   | ボタン入力2（全消灯） |
| `BUTTON_PIN2`  | GPIO35   | ボタン入力3（一部点灯） |

#### 動作説明

1. **初期化（setup関数）**
    - LEDピンを出力モードに設定。
    - ボタンピンを `INPUT_PULLUP` モードで入力に設定。

2. **ループ処理（loop関数）**
    - 各ボタンの押下状態を `digitalRead()` で確認。
    - 条件に応じてLEDの点灯/消灯を `digitalWrite()` で制御。
    - ボタンはプルアップ入力なので、押されているとき `LOW` になります。

```cpp
// LEDのピン番号を定義（LED_BUILTIN0〜2にそれぞれGPIO15, GPIO34, GPIO33を割り当て）
#define LED_BUILTIN0 15
#define LED_BUILTIN1 34 
#define LED_BUILTIN2 33

// ボタンのピン番号を定義（BUTTON_PIN0〜2にそれぞれGPIO12, GPIO13, GPIO35を割り当て）
#define BUTTON_PIN0 12
#define BUTTON_PIN1 13
#define BUTTON_PIN2 35

void setup() {
  // LED用のGPIOピンを出力モードに設定
  pinMode(LED_BUILTIN0, OUTPUT); // LED_BUILTIN0 を出力モードに
  pinMode(LED_BUILTIN1, OUTPUT); // LED_BUILTIN1 を出力モードに
  pinMode(LED_BUILTIN2, OUTPUT); // LED_BUILTIN2 を出力モードに

  // ボタン用のGPIOピンを入力プルアップモードに設定（ボタンが押されたとき LOW になる）
  pinMode(BUTTON_PIN0, INPUT_PULLUP); // BUTTON_PIN0 を入力（プルアップ）
  pinMode(BUTTON_PIN1, INPUT_PULLUP); // BUTTON_PIN1 を入力（プルアップ）
  pinMode(BUTTON_PIN2, INPUT_PULLUP); // BUTTON_PIN2 を入力（プルアップ）
}

void loop() {
  // ボタン0が押されたとき（LOW）、すべてのLEDを点灯
  if(digitalRead(BUTTON_PIN0) == LOW){
    digitalWrite(LED_BUILTIN0, HIGH); // LED0 点灯
    digitalWrite(LED_BUILTIN1, HIGH); // LED1 点灯
    digitalWrite(LED_BUILTIN2, HIGH); // LED2 点灯
  }
  // ボタン1が押されたとき（LOW）、すべてのLEDを消灯
  else if(digitalRead(BUTTON_PIN1) == LOW){
    digitalWrite(LED_BUILTIN0, LOW);  // LED0 消灯
    digitalWrite(LED_BUILTIN1, LOW);  // LED1 消灯
    digitalWrite(LED_BUILTIN2, LOW);  // LED2 消灯
  }
  // ボタン2が押されたとき（LOW）、LED0とLED2を点灯、LED1を消灯
  else if(digitalRead(BUTTON_PIN2) == LOW){
    digitalWrite(LED_BUILTIN0, HIGH); // LED0 点灯
    digitalWrite(LED_BUILTIN1, LOW);  // LED1 消灯
    digitalWrite(LED_BUILTIN2, HIGH); // LED2 点灯
  }
}

```

??? Note
    著者:Shion Noguchi
